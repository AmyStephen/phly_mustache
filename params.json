{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Phly\\Mustache is a Mustache (http://mustache.github.com) implementation written\r\nfor PHP 5.3+. It conforms to the principles of mustache, and allows for\r\nextension of the format via pragmas.\r\n\r\nFor full documentation, please visit \r\n[ReadTheDocs](http://phly_mustache.readthedocs.org/).\r\n\r\nAt this time, it has support for the following:\r\n\r\n- `PhlyTest\\Mustache\\Mustache`\r\n  - Renders string templates\r\n  - Renders file templates\r\n  - Can use object properties for substitutions\r\n  - Can use method return value for substitutions\r\n  - Template may use conditionals\r\n  - Conditional is skipped if value is false\r\n  - Conditional is skipped if value is empty\r\n  - Template iterates arrays\r\n  - Template iterates traversable objects\r\n  - Higher order sections render inside out\r\n  - Template will dereference nested arrays\r\n  - Template will dereference nested objects\r\n  - Inverted sections render on empty values\r\n  - Renders partials\r\n  - Allows aliasing partials\r\n  - Escapes standard characters\r\n  - Triple mustaches prevent escaping\r\n  - Honors implicit iterator pragma\r\n  - Allows setting alternate template suffix\r\n  - Strips comments from rendered output\r\n  - Allows specifying alternate delimiters\r\n  - Alternate delimiters set in section only apply to that section\r\n  - Alternate delimiters apply to child sections\r\n  - Alternate delimiters do not carry to partials\r\n  - Pragmas are section specific\r\n  - Pragmas do not extend to partials\r\n  - Handles recursive partials\r\n  - Lexer strips unwanted whitespace from tokens\r\n  - Array values that refer to p h p built ins should not call them\r\n  - Object properties that refer to p h p built ins should not call them\r\n  - Array values that refer to static methods should not call them\r\n  - String values that refer to functions should not call them\r\n  - Array values that refer to static methods in array syntax should not call them\r\n  - Std class as view should not raise error\r\n  - Dot notation is exanded to sub property of view\r\n  - With dot notation if subproperty does not exist empty string is rendered\r\n\r\n- `PhlyTest\\Mustache\\HierarchicalViews`\r\n  - Understands hierarchical templates\r\n  - Placeholders are rendered as unnamed sections\r\n  - Only placeholders with replacements receive substitutions\r\n  - Can render multiple placeholders\r\n  - Can render nested child placeholders\r\n  - Nested children can render placeholders defined in parent child\r\n\r\n- `PhlyTest\\Mustache\\DefaultResolver`\r\n  - Resolves using mustache suffix by default\r\n  - Resolves using provided suffix\r\n  - Resolves using specified directory separator\r\n  - Uses path stack internally\r\n\r\n- `PhlyTest\\Mustache\\Pragma\\SubViews`\r\n  - Sub view content is captured in parent\r\n  - Renders nested sub views\r\n  - Sub view uses parent view when no view provided\r\n  - Should render sub view returned by closure\r\n  - Std class composing sub view should not raise error\r\n\r\n\r\nArchitecture\r\n============\r\n\r\nPhly\\Mustache consists of five primary classes:\r\n\r\n- Lexer: tokenizes mustache syntax.\r\n- Renderer: renders a list of tokens, using substitions provided via a view.\r\n- Pragma: interface for pragmas, which may modify how tokens are handled\r\n- Resolver: resolves a template name to mustache syntax or tokens.\r\n- Mustache: facade/gateway class. Tokenizes and renders templates, caches\r\n  tokens, provides partial aliasing, and acts as primary interface for\r\n  end-users.\r\n\r\nUsage\r\n=====\r\nUsage is fairly straightforward:\r\n\r\n    include '/path/to/library/Phly/Mustache/_autoload.php';\r\n    use Phly\\Mustache\\Mustache;\r\n\r\n    $mustache = new Mustache();\r\n    echo $mustache->render('some-template', $view);\r\n\r\nBy default, phly_mustache will look under the current directory for templates\r\nending with '.mustache'; you can create a stack of directories to search by\r\nusing the setTemplatePath() method:\r\n\r\n    $mustache->setTemplatePath($path1)\r\n             ->setTemplatePath($path2);\r\n\r\nIn the above, it will search first $path2, then $path1 to resolve the template.\r\n\r\nYou may also change the suffix it will use to resolve templates:\r\n\r\n    $mustache->setSuffix('html'); // use '.html' as the suffix\r\n\r\nIf your templates use pragmas, you must first add pragma handlers to the\r\nrenderer. This can be done as follows:\r\n\r\n    use Phly\\Mustache\\Pragma\\ImplicitIterator as ImplicitIteratorPragma;\r\n    $mustache->getRenderer()->addPragma(new ImplicitIteratorPragma());\r\n    $mustache->render('template-with-pragma', $view);\r\n\r\nViews can be either associative arrays or objects. For objects, any public\r\nmember, either a property or a method, may be referenced in your template. As an\r\nexample:\r\n\r\n    class View\r\n    {\r\n        public $first_name = 'Matthew';\r\n\r\n        public $last_name  = \"Weier O'Phinney\";\r\n\r\n        public function full_name()\r\n        {\r\n            return $this->first_name . ' ' . $this->last_name;\r\n        }\r\n    }\r\n\r\nAny property (or array key) may also refer to a valid callback; in such cases,\r\nthe return value of the callback will be used.\r\n\r\n    $view = new \\stdClass;\r\n    $view->first_name = 'Matthew';\r\n    $view->last_name  = \"Weier O'Phinney\";\r\n    $view->full_name  = function() use ($view) {\r\n        return $view->first_name . ' ' . $view->last_name;\r\n    };\r\n\r\nThe following sections detail unique and/or advanced features of phly_mustache.\r\n\r\nAutoloading\r\n===========\r\nphly_mustache follows the PSR-0 standard for class naming conventions, meaning\r\nany PSR-0-compliant class loader will work. To simplify things out of the box,\r\nthe component contains an \"\\_autoload.php\" file which will register an autoloader\r\nfor the phly_mustache component with spl_autoload. You can simply include that\r\nfile, and start using phly_mustache.\r\n\r\nHigher Order Sections\r\n=====================\r\n\"Higher order sections\" refer to callbacks that return callbacks. As an example,\r\nconsider the following template:\r\n\r\n    {{#bolder}}Hi {{name}}.{{/bolder}}\r\n\r\nand the following view:\r\n    \r\n    $view = new \\stdClass;\r\n    $view->name = 'Tater';\r\n    $view->bolder = function() {\r\n        return function($text, $renderer) {\r\n            return '<b>' . $renderer($text) . '</b>';\r\n        };\r\n    };\r\n\r\nIn this case, the contents of the section, \"Hi {{name}}.\" will be passed as the\r\nfirst argument to the section, and a callback capable of rendering will be\r\npassed as the second (this is basically a closure that curries in the current\r\nRenderer object and calls the appropriate method). This allows you to re-use a\r\ngiven \"section\" in order to create re-usable capabilities; think of them like\r\n\"view helpers\" in systems like Zend_View, Solar_View, Savant, etc.\r\n\r\nPartials\r\n========\r\nPartials are a basic form of inclusion within Mustache; anytime you find you\r\nhave re-usable bits of templates, move them into a partial, and refer to the\r\npartial from the parent template.\r\n\r\nTypically, you will only reference partials within your templates, using\r\nstandard syntax:\r\n\r\n    {{>partial-name}}\r\n\r\nHowever, you may optionally pass a list of partials when rendering. When you do\r\nso, the list should be a set of alias/template pairs:\r\n\r\n    $mustache->render($template, array(), array(\r\n        'winnings' => 'user-winnings',\r\n    ));\r\n\r\nIn the above example, 'winnings' refers to the template\r\n\"user-winnings.mustache\". Thus, within the $template being rendered, you may\r\nrefer to the following partial:\r\n\r\n    {{>winnings}}\r\n\r\nand it will resolve to the appropriate aliased template.\r\n\r\nA few things to remember when using partials:\r\n\r\n - The parent template may change tag delimiters, but if you want to use the\r\n   same delimiters in your partial, you will need to make the same declaration.\r\n - The parent template may utilize one or more pragmas, but those declarations\r\n   will not perist to the partial; if you want those pragmas, you must reference\r\n   them in your partial.\r\n\r\nBasically, partials render in their own scope. If you remember that one rule,\r\nyou should have no problems.\r\n\r\nHierarchical Views and Placeholders\r\n===================================\r\n\r\n(Available in versions 1.1.0 and up).\r\n\r\nPlaceholders are basically unnamed sections, and are denoted by the combination\r\nof `{{$name}}` and `{{/name}}`. When encountered by the renderer, any mustache\r\ncontent within will be rendered as normal mustache content.\r\n\r\nPlaceholders are primarily of use with the concept of hierarchical views. These\r\nare denoted by the combination of `{{<name}}` and `{{/name}}`. When encountered,\r\nthe template denoted by `name` will be tokenized, and any placeholders that are\r\ndefined in the content will be used to replace those found in the parent\r\ntemplate.\r\n\r\nAs an example, consider the following parent template, \"super.mustache\":\r\n\r\n    <html>\r\n    <head><title>{{$title}}Default title{{/title}}</title></head>\r\n    <body>\r\n    <div class=\"content\">\r\n    {{$content}}Default content of the page{{/content}}\r\n    </div>\r\n    </body>\r\n    </html>\r\n\r\nIf rendered by itself, it will result in the following:\r\n\r\n    <html>\r\n    <head><title>Default title</title></head>\r\n    <body>\r\n    <div class=\"content\">\r\n    Default content of the page\r\n    </div>\r\n    </body>\r\n    </html>\r\n\r\nNow, consider the following child template, \"sub.mustache\":\r\n\r\n    {{<super}}\r\n    {{$title}}Profile of {{username}}{{/title}}\r\n    {{$content}}\r\n    Here is {{username}}'s profile page\r\n    {{/content}}\r\n    {{/super}}\r\n\r\nIf we have a view that defines \"username\" as \"Matthew\" and render\r\n\"sub.mustache\", we'll get the following:\r\n\r\n    <html>\r\n    <head><title>Profile of Matthew</title></head>\r\n    <body>\r\n    <div class=\"content\">\r\n    Here is Matthew's profile page\r\n    </div>\r\n    </body>\r\n    </html>\r\n\r\nNotice how the child retains the view context of the parent, and that all\r\nmustache tokens defined in it are rendered as if they were simply another\r\nmustache template.\r\n\r\nHierarchical templates may be nested arbitrarily deep.\r\n\r\n(This feature was inspired by https://gist.github.com/1854699)\r\n\r\nWhitespace Stripping\r\n====================\r\nBecause this is a very literal compiler, whitespace can sometimes be an issue. A\r\nnumber of measures have been built in to reduce such issues by stripping\r\nwhitespace (primarily newlines) surrounding certain tokens, but they come at a\r\nslight performance penalty.\r\n\r\nFor markup languages like XML, XHTML or HTML5, you likely will not run into\r\nissues in the final rendered output. As such, you can optionally disable\r\nwhitespace stripping:\r\n\r\n    $mustache->getLexer()->disableStripWhitespace(true);\r\n\r\nCaching Tokens\r\n==============\r\nTokens from parsed templates may be cached for later usage; alternately, a new\r\ninstance of phly_mustache may be seeded with cached tokens from a previous\r\ninstance. \r\n\r\nTo get the list of tokens, use the following:\r\n\r\n    $tokens = $mustache->getAllTokens();\r\n\r\nThis will return a list of template name/token list pairs, based on the\r\ntemplates compiled by this instance. You may then seed another instance using\r\nthe following:\r\n\r\n    $mustache->restoreTokens($tokens);\r\n\r\nThis will overwrite any tokens already compiled by that instance.\r\n\r\nSince the tokens are template name/token list pairs, you can safely pass them to\r\narray_merge(), allowing multiple instances of phly_mustache to build up a large\r\ncache of template tokens. This will greatly improve performance when rendering\r\ntemplates on subsequent calls -- particularly if you cache the tokens in a\r\nmemory store such as memcached.\r\n\r\nPragmas\r\n=======\r\nPragmas are tags of the form:\r\n\r\n {{%PRAGMA-NAME option=value}}\r\n\r\nwhere options are key/value pairs, and are entirely optional. Pragmas are\r\nuser-defined, and can be used to extend and/or modify the capabilities of the\r\nrenderer.\r\n\r\nPragmas should implement Phly\\Mustache\\Pragma, which defines methods for\r\nretrieving the pragma name (used during registration of the pragma, and\r\nreferenced by templates; this is case sensitive currently), determining whether\r\nor not the pragma can intercept rendering of a specific token type, and handling\r\nthe token. \r\n\r\nPragmas should be registered _before_ rendering any template that references\r\nthem. \r\n\r\n    $this->mustache->getRenderer()->addPragma($pragmaObject);\r\n    // ...\r\n    $this->mustache->render(/*...*/);\r\n\r\nWhen declared in a template, they exist for the duration of the current\r\nscope, which means:\r\n\r\n - If declared in a section, they apply to that section and any child sections\r\n   *only*\r\n - If declared for a file, they apply to that file and all child sections *only*\r\n - Pragmas are never passed on to partials; each partial is rendered with an\r\n   empty set of pragmas, and must declare any pragmas it requires for\r\n   appropriate rendering.\r\n\r\nFor ideas on how you might use or implement pragmas, examine the pragmas shipped\r\nwith phly_mustache.\r\n\r\nPragmas shipped with phly_mustache\r\n----------------------------------\r\n\r\nIMPLICIT-ITERATOR\r\nThis pragma allows iteration of indexed arrays or Traversable objects with\r\nscalar values, with the option of specifying the iterator \"key\" to use within\r\nthe template. By default, a variable key \".\" will be replaced by the current\r\nvalue of the iterator.\r\n\r\nA sample template:\r\n\r\n    {{#some_iterable_data}}\r\n        {{.}}\r\n    {{/some_iterable_data}}\r\n\r\nTo use an explicit iterator key, specify it via the \"iterator\" option of the\r\npragma:\r\n\r\n    {{%IMPLICIT-ITERATOR iterator=bob}}\r\n    {{#some_iterable_data}}\r\n        {{bob}}\r\n    {{/some_iterable_data}}\r\n\r\nSUB-VIEWS\r\nThe Sub-Views pragma allows you to implement the two-step view pattern using\r\nMustache. When active, any variable whose value is an instance of\r\nPhly\\Mustache\\Pragma\\SubView will be substituted by rendering the template and\r\nview that object encapsulates.\r\n\r\nThe SubView class takes a template name and a view as a constructor:\r\n\r\n    use Phly\\Mustache\\Pragma\\SubView;\r\n    $subView = new SubView('some-partial', array('name' => 'Matthew'));\r\n\r\nThat object is then assigned as a value to a view key:\r\n\r\n    $view = new \\stdClass;\r\n    $view->content = $subView;\r\n\r\nThe template might look like this:\r\n\r\n    {{!layout}}\r\n    {{%SUB-VIEWS}}\r\n    <html>\r\n    <body>\r\n        {{content}}\r\n    </body>\r\n    </html>\r\n\r\nand the partial like this:\r\n\r\n    {{!some-partial}}\r\n    Hello, {{name}}!\r\n\r\nRendering the view:\r\n\r\n    use Phly\\Mustache\\Mustache,\r\n        Phly\\Mustache\\Pragma\\SubViews;\r\n    $mustache = new Mustache();\r\n    $subViews = new SubViews($mustache);\r\n    $rendered = $mustache->render('layout', $view);\r\n\r\nwill result in:\r\n\r\n    <html>\r\n    <body>\r\n        Hello, Matthew!\r\n    </body>\r\n    </html>\r\n\r\nSub views may be nested, and re-used.\r\n","name":"phly_mustache","google":"","tagline":"PHP 5.3 Mustache implementation"}